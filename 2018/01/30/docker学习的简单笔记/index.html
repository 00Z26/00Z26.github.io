<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="author" content="John Doe"><title>docker学习的简单笔记 · 一寸一朝</title><meta name="description" content="构建镜像dockerfile构建12345678910FROM	debian:jessieRUN	build Deps='gcc	libc6-dev	make'	\		&amp;amp;&amp;amp;	apt-get	update	\		&amp;amp;&amp;amp;	apt-get	install	-y	$buildD"><meta name="keywords" content=""><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="renderer" content="webkit"><link rel="short icon" href="/images/favicon.png" type="image/x-icon"><link rel="stylesheet" href="/css/bootstrap.min.css"><link rel="stylesheet" href="/css/font-awesome.min.css"><link rel="stylesheet" href="/css/style.css"><link rel="alternate" type="application/atom+xml" title="ATOM 1.0" href="/atom.xml"></head><body><div id="stage" class="container"><div class="row"><div id="side-bar" class="col-sm-3 col-xs-12 side-container invisible"><div class="vertical-text site-title"><h3 tabindex="-1" class="site-title-small"><a href="/" class="a-title">Be weird together.</a></h3><h1 tabindex="-1" class="site-title-large"><a href="/" class="a-title">何问一寸一朝</a></h1><!--h6(onclick="triggerSiteNav()") Trigger--></div><br class="visible-lg visible-md visible-sm"><div id="site-nav" class="site-title-links"><ul><li><a href="/">Home</a></li><li><a href="/archives">Archive</a></li><li><a href="/tags">Tags</a></li><li class="soc"><a href="http://yoursite.com/atom.xml" target="_blank" rel="noopener noreferrer"><i class="fa fa-rss">&nbsp;</i></a></li></ul><div class="visible-lg visible-md visible-sm site-nav-footer"><br class="site-nav-footer-br"><footer><p>&copy;&nbsp;2018&nbsp;<a target="_blank" href="http://yoursite.com" rel="noopener noreferrer">John Doe</a></p><p>Theme&nbsp;<a target="_blank" href="https://github.com/SumiMakito/hexo-theme-typography" rel="noopener noreferrer">Typography</a>&nbsp;by&nbsp;<a target="_blank" href="https://www.keep.moe" rel="noopener noreferrer">Makito</a></p><p>Proudly published with&nbsp;<a target="_blank" href="https://hexo.io" rel="noopener noreferrer">Hexo</a></p></footer></div></div></div><div id="main-container" class="col-sm-9 col-xs-12 main-container invisible"><div class="autopagerize_page_element"><div class="content"><div class="post-page"><div class="post-container"><p class="post-title"><a>docker学习的简单笔记</a></p><p class="post-meta"><span class="date meta-item">Posted at&nbsp;2018-01-30</span><span class="meta-item"><i class="fa fa-tag"></i><span>&nbsp;</span><a href="/tags/docker/" title="docker" class="a-tag">docker</a><span>&nbsp;</span></span></p><p class="post-abstract"><h2 id="构建镜像"><a href="#构建镜像" class="headerlink" title="构建镜像"></a>构建镜像</h2><h3 id="dockerfile构建"><a href="#dockerfile构建" class="headerlink" title="dockerfile构建"></a>dockerfile构建</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">FROM	debian:jessie</span><br><span class="line">RUN	build Deps=<span class="string">'gcc	libc6-dev	make'</span>	\</span><br><span class="line">		&amp;&amp;	apt-get	update	\</span><br><span class="line">		&amp;&amp;	apt-get	install	-y	$buildDeps	\</span><br><span class="line">		&amp;&amp;	wget	-O	redis.tar.gz	<span class="string">"http://download.redis.io/releases/redis-3.2.5.tar.gz"</span>	\</span><br><span class="line">		......</span><br><span class="line">		&amp;&amp;	rm	-rf	/var/lib/apt/lists<span class="comment">/*	\</span></span><br><span class="line"><span class="comment">		&amp;&amp;	rm	redis.tar.gz	\</span></span><br><span class="line"><span class="comment">		&amp;&amp;	rm	-r	/usr/src/redis	\</span></span><br><span class="line"><span class="comment">		&amp;&amp;	apt-get	purge	-y	--auto-remove	$buildDeps</span></span><br></pre></td></tr></table></figure>
<p>Dockerfile文件的格式 第一句一定是FROM，RUN是指执行命令，并在最后一句清除了apt缓存<br>使用dockerfile建立镜像：<code>docker build [选项] &lt;上下文路径/URL/-&gt;</code><br>定制镜像时还会使用copy和add添加本地文件。<br>当构建的时候,用户会指定构建镜像上下文的路径,     docker<br>build命令得知这个路径后,会将路径下的所有内容打包,然后上传给Docker引擎。<br>如果在dockerfile中写：<br><code>COPY ./package.json /app/</code><br>不是要复制执行docker build 命令所在的目录下的package.json,也不是复制Dockerfile所在目录下的package.json    ,而是复制上下文(context)目录下的package.json。<br>.dockeringnore 指无视文件不上传</p>
<h3 id="其他方法"><a href="#其他方法" class="headerlink" title="其他方法"></a>其他方法</h3><h4 id="1、git-repo"><a href="#1、git-repo" class="headerlink" title="1、git repo"></a>1、<code>git repo</code></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$	docker	build	https:<span class="comment">//github.com/twang2218/gitlab-ce-zh.git#:8.14</span></span><br><span class="line">docker	build	https:<span class="comment">//github.com/twang2218/gitlab-ce-zh.git\#:8.14</span></span><br><span class="line">Sending	build	context	to	Docker	daemon	<span class="number">2.048</span>	kB</span><br><span class="line">Step	<span class="number">1</span>	:	FROM	gitlab/gitlab-ce:<span class="number">8.14</span>.0-ce.0</span><br><span class="line"><span class="number">8.14</span>.0-ce.0:	Pulling	from	gitlab/gitlab-ce</span><br><span class="line">aed15891ba52:	Already	exists</span><br></pre></td></tr></table></figure>
<p>支持URL构建。</p>
<h4 id="2、tar压缩包构建"><a href="#2、tar压缩包构建" class="headerlink" title="2、tar压缩包构建"></a>2、tar压缩包构建</h4><p><code>$ docker build    http://server/context.tar.gz</code><br>读取指定压缩包<br><code>$ docker build - &lt; Dockerfile</code><br>读取dockerfile<br><code>$ docker build - &lt; context.tar.gz</code><br>读取上下文压缩包</p>
<h2 id="docker基本命令解析"><a href="#docker基本命令解析" class="headerlink" title="docker基本命令解析"></a>docker基本命令解析</h2><h3 id="1、copy"><a href="#1、copy" class="headerlink" title="1、copy"></a>1、copy</h3><p><code>COPY package.json /usr/src/app/</code><br>后面的目录为目标路径，目标路径为容器内的绝对路径。</p>
<h3 id="2、add"><a href="#2、add" class="headerlink" title="2、add"></a>2、add</h3><p>与COPY形式性质基本一致，增加了功能。<br><code>ADD ubuntu-xenial-core-cloudimg-amd64-root.tar.gz /</code><br>自动解压缩，源文件是url的话可以自动下载。<br>官方文档要求尽量使用COPY</p>
<h3 id="3、cmd"><a href="#3、cmd" class="headerlink" title="3、cmd"></a>3、cmd</h3><p>容器启动命令。<br>两种格式：</p>
<ul>
<li>shell格式：<code>CMD    &lt;命令&gt;</code></li>
<li>exec格式：<code>CMD [&quot;可执行文件&quot;, &quot;参数1&quot;, &quot;参数2&quot;...]</code></li>
<li>参数列表格式：<code>CMD [&quot;参数1&quot;, &quot;参数2&quot;...]</code>   在指定了ENTRYPOINT指令后,用CMD指定具体的参数。</li>
</ul>
<p>一般推荐使用exec格式。<br>Docker不是虚拟机,容器中的应用都应该以前台执行,而不是像虚拟机、物理机里面那样,用upstart/systemd    去启动后台服务,容器内没有后台服务的概念。<br>反例：<code>CMD service nginx start</code> 即 <code>CMD    [&quot;sh&quot;, &quot;-c&quot;, &quot;service nginx start&quot;]</code><br>主进程是sh即在执行完命令start后sh作为主进程退出后，容器也跟着退出。<br>正例：<code>CMD    [&quot;nginx&quot;, &quot;-g&quot;, &quot;daemon off;&quot;]</code><br>这时主进程是nginx。</p>
<h3 id="4、ENTRYPOINT"><a href="#4、ENTRYPOINT" class="headerlink" title="4、ENTRYPOINT"></a>4、ENTRYPOINT</h3><p>入口点。<br>用来指定程序启动命令及参数。<br>当指定了ENTRYPOINT后, CMD的含义就发生了改变,不再是直接的运行其命令,而是将CMD的内容作为参数传给ENTRYPOINT指令。</p>
<ul>
<li>场景一<br>让镜像像命令使用。拿curl命令为例子，在构建镜像时用<code>CMD [&quot;curl&quot;,&quot;-s&quot;,&quot;http://ip.cn&quot;]</code>来进行ip查询的命令时，如果要在使用时增加其他选项，则需要重新输入整个命令，即<code>$ docker run myip curl -s http://ip.cn -i</code>。<br>而使用<code>ENTRYPOINT [ &quot;curl&quot;, &quot;-s&quot;, &quot;http://ip.cn&quot;]</code>可以直接<code>docker run myip -i</code>。</li>
<li>场景二<br>应用运行前的准备工作<br>这些准备工作是和容器CMD无关的,无论CMD为什么,都需要事先进行一个预处理的工作。这种情况下,可以写一个脚本,然后放入         ENTRYPOINT中去执行,而这个脚本会将接到的参数(也就是<cmd>)作为命令,在脚本最后执行。.sh是脚本文件。</cmd></li>
</ul>
<h3 id="5、ENV设置环境变量"><a href="#5、ENV设置环境变量" class="headerlink" title="5、ENV设置环境变量"></a>5、ENV设置环境变量</h3><ul>
<li><code>ENV &lt;key&gt; &lt;value&gt;</code></li>
<li><code>ENV    &lt;key1&gt;=&lt;value1&gt;    &lt;key2&gt;=&lt;value2&gt;...</code></li>
</ul>
<p>设置环境变量方便维护。</p>
<h3 id="6、ARG构建参数"><a href="#6、ARG构建参数" class="headerlink" title="6、ARG构建参数"></a>6、ARG构建参数</h3><p>格式:<code>ARG &lt;参数名&gt;[=&lt;默认值&gt;]</code><br>–build-arg选项的参数必须在dockerfile中用ARG定义过，不然在build过程中会发出警告并继续构建。</p>
<h3 id="7、volume定义匿名卷"><a href="#7、volume定义匿名卷" class="headerlink" title="7、volume定义匿名卷"></a>7、volume定义匿名卷</h3><ul>
<li><code>VOLUME [&quot;&lt;路径1&gt;&quot;, &quot;&lt;路径2&gt;&quot;...]</code>    </li>
<li><code>VOLUME &lt;路径&gt;</code></li>
</ul>
<p>运行时应保证容器储存层不发生写操作。对于数据库类需要保存动态数据的应用,其数据库文件应该保存于卷(volume)中。<br>在dockerfile的构建中可以提前指定某个目录挂载为匿名卷：<code>VOLUME /data</code><br>运行时可以覆盖这个挂载设置。比如:<br><code>docker run -d -v mydata:/data xxxx</code><br>在这行命令中,就使用了mydata这个命名卷挂载到了/data这个位置,替代了Dockerfile中定义的匿名卷的挂载配置。</p>
<h3 id="8、expose声明端口"><a href="#8、expose声明端口" class="headerlink" title="8、expose声明端口"></a>8、expose声明端口</h3><p><code>EXPOSE    &lt;端口1&gt;[&lt;端口2&gt;...]</code><br>在运行时使用<br>随机端口映射时,也就是<code>docker run -P</code>时,会自动随机映射EXPOSE的端口。但在文件内仅仅是声明，不会因此而开放该端口。<br>注意区分docker run里的-p选项是映射端口。</p>
<h3 id="9、workdir指定工作路径"><a href="#9、workdir指定工作路径" class="headerlink" title="9、workdir指定工作路径"></a>9、workdir指定工作路径</h3><p>格式为    <code>WORKDIR &lt;工作目录路径&gt;</code><br>更改到某一目录下修改某个文件时用这个指定目录。</p>
<h3 id="10、user指定当前目录"><a href="#10、user指定当前目录" class="headerlink" title="10、user指定当前目录"></a>10、user指定当前目录</h3><p>格式: <code>USER &lt;用户名&gt;</code><br>同上，改变环境状态并影响之后的层。（P92 gosu命令？）</p>
<h3 id="11、healthcheck健康检查"><a href="#11、healthcheck健康检查" class="headerlink" title="11、healthcheck健康检查"></a>11、healthcheck健康检查</h3><p>格式:<br>    <code>HEALTHCHECK [选项] CMD &lt;命令&gt;</code>:设置检查容器健康状况的命令<br>    <code>HEALTHCHECK NONE</code>:如果基础镜像有健康检查指令,使用这行可以屏蔽掉其健康检查指令。<br>HEALTHCHECK指令是告诉Docker应该如何进行判断容器的状态是否正常。（死锁是什么？）<br>HEALTHCHECK支持下列选项:</p>
<ul>
<li>–interval=&lt;间隔&gt;    :两次健康检查的间隔,默认为    30    秒;</li>
<li>–timeout=&lt;时长&gt;:健康检查命令运行超时时间,如果超过这个时间,本次健康检查就被<br>视为失败,默认30秒;</li>
<li>–retries=&lt;次数&gt;:当连续失败指定次数后,则将容器状态视为unhealthy,默认3次。</li>
</ul>
<p>这个命令只写一次，重复多次时最后一次healthcheck生效。<br>为了帮助排障,健康检查命令的输出(包括stdout以及stderr)都会被存储于健康状态里,可以用<code>docker inspect</code>来查看。<br><code>docker ps</code>可以用来查看状态。</p>
<h3 id="12、onbulid"><a href="#12、onbulid" class="headerlink" title="12、onbulid"></a>12、onbulid</h3><p>”为他人作嫁衣裳“<br>该命令不会立即执行，而是当前构建的镜像作为基础镜像被引用时才会执行。<br>多次使用同一镜像，镜像更新时方便维护。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">FROM node:slim</span><br><span class="line">RUN mkdir /app</span><br><span class="line">WORKDIR /app</span><br><span class="line">ONBUILD COPY ./<span class="keyword">package</span>.json  /app</span><br><span class="line">ONBUILD RUN	[<span class="string">"npm"</span>, <span class="string">"install"</span>]</span><br><span class="line">ONBUILD COPY . /app/</span><br><span class="line">CMD [ <span class="string">"npm"</span>, <span class="string">"start"</span> ]</span><br></pre></td></tr></table></figure></p>
<p>然后在其他应用则 <code>FROM my nginx</code><br>就可以成功的将当前项目的代码复制进镜像、并且针对本项目执行<code>npm install</code>,生成应用镜像</p>
<h3 id="13、多阶段共建"><a href="#13、多阶段共建" class="headerlink" title="13、多阶段共建"></a>13、多阶段共建</h3><p>推荐采用多阶段构建的方法。就，多写几个run。</p>
<h2 id="制作镜像的其他方式"><a href="#制作镜像的其他方式" class="headerlink" title="制作镜像的其他方式"></a>制作镜像的其他方式</h2><h3 id="1、从rootfs压缩包导入"><a href="#1、从rootfs压缩包导入" class="headerlink" title="1、从rootfs压缩包导入"></a>1、从rootfs压缩包导入</h3><p>格式: <code>docker import [选项] &lt;文件&gt;|&lt;URL&gt;|- [&lt;仓库名&gt;[:&lt;标签&gt;]]</code><br>压缩包可以是本地文件、远程    Web    文件,甚至是从标准输入中得到。压缩包将会在镜像目录展开,并直接作为镜像第一层提交。</p>
<h3 id="2、docker-save-和-docker-load"><a href="#2、docker-save-和-docker-load" class="headerlink" title="2、docker save 和 docker load"></a>2、docker save 和 docker load</h3><p>用以将镜像保存为一个tar文件,然后传输到另一个位置上,再加载进来。现不推荐。<br>保存镜像的命令为:<br><code>$ docker save alpine | gzip &gt; alpine-latest.tar.gz</code><br>加载：<br><code>$    docker    load    -i    alpine-latest.tar.gz</code><br>也可以：<br><code>ocker    save    &lt;镜像名&gt;    |    bzip2    |    pv    |    ssh    &lt;用户名&gt;@&lt;主机名&gt;    &#39;cat    |    docker    load&#39;</code><br>pv:使用pv命令度量执行命令的具体信息:时间,进度.</p>
<h2 id="操作docker容器"><a href="#操作docker容器" class="headerlink" title="操作docker容器"></a>操作docker容器</h2><h2 id="访问仓库"><a href="#访问仓库" class="headerlink" title="访问仓库"></a>访问仓库</h2><p>用户名:620z</p>
<h2 id="数据管理"><a href="#数据管理" class="headerlink" title="数据管理"></a>数据管理</h2><p>docker container stop web<br>docker rm web<br>停止和删除的区别？<br>数据卷命令 -v和-mount有什么区别，为什么-mount时会报错unknown flag ： –mount<br>P135</p>
<h2 id="使用网络"><a href="#使用网络" class="headerlink" title="使用网络"></a>使用网络</h2><p>Docker允许通过外部访问容器或容器互联的方式来提供网络服务。<br>docker ps -l和docker container ls 有什么区别</p>
<h3 id="配置DNS-？？"><a href="#配置DNS-？？" class="headerlink" title="配置DNS ？？"></a>配置DNS ？？</h3></p></div><div class="share"><span>Share</span>&nbsp;<span class="soc"><a href="javascript:(function(){EN_CLIP_HOST='http://www.evernote.com';try{var%20x=document.createElement('SCRIPT');x.type='text/javascript';x.src=EN_CLIP_HOST+'/public/bookmarkClipper.js?'+(new%20Date().getTime()/100000);document.getElementsByTagName('head')[0].appendChild(x);}catch(e){location.href=EN_CLIP_HOST+'/clip.action?url='+encodeURIComponent(location.href)+'&amp;title='+encodeURIComponent(document.title);}})();" ref="nofollow" target="_blank" class="fa fa-bookmark"></a></span><span class="soc"><a href="javascript:void((function(s,d,e){try{}catch(e){}var f='http://service.weibo.com/share/share.php?',u=d.location.href,p=['url=',e(u),'&amp;title=',e(d.title),'&amp;appkey=2924220432'].join('');function a(){if(!window.open([f,p].join(''),'mb',['toolbar=0,status=0,resizable=1,width=620,height=450,left=',(s.width-620)/2,',top=',(s.height-450)/2].join('')))u.href=[f,p].join('');};if(/Firefox/.test(navigator.userAgent)){setTimeout(a,0)}else{a()}})(screen,document,encodeURIComponent));" class="fa fa-weibo"></a></span><span class="soc"><a href="http://twitter.com/home?status=http://yoursite.com/2018/01/30/docker学习的简单笔记/%20一寸一朝%20docker学习的简单笔记" class="fa fa-twitter"></a></span></div><div class="pagination"><p class="clearfix"><span class="pre pagbuttons"><a role="navigation" href="/2018/02/02/HTTP权威指南阅读笔记/" title="HTTP权威指南阅读笔记"><i class="fa fa-angle-double-left"></i>&nbsp;Previous post: HTTP权威指南阅读笔记</a></span><span>&nbsp;</span><span class="next pagbuttons"><a role="navigation" href="/2018/01/20/dear-zx/" title="dear zx">Next post: dear zx&nbsp;<i class="fa fa-angle-double-right"></i></a></span></p></div></div></div></div><div class="visible-xs site-bottom-footer"><footer><p>&copy;&nbsp;2018&nbsp;<a target="_blank" href="http://yoursite.com" rel="noopener noreferrer">John Doe</a></p><p>Theme&nbsp;<a target="_blank" href="https://github.com/SumiMakito/hexo-theme-typography" rel="noopener noreferrer">Typography</a>&nbsp;by&nbsp;<a target="_blank" href="https://www.keep.moe" rel="noopener noreferrer">Makito</a></p><p>Proudly published with&nbsp;<a target="_blank" href="https://hexo.io" rel="noopener noreferrer">Hexo</a></p></footer></div></div></div></div><script src="/js/jquery-3.1.0.min.js"></script><script src="/js/bootstrap.min.js"></script><script src="/js/jquery-migrate-1.2.1.min.js"></script><script src="/js/jquery.appear.js"></script><script src="/js/google-analytics.js"></script><script src="/js/typography.js"></script></body></html>